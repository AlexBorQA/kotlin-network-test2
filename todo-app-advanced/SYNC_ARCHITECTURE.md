# Архитектура синхронизации Todo App

## Обзор

Приложение использует подход **offline-first** с автоматической синхронизацией данных между локальной базой данных и удалённым сервером.

## Компоненты

### 1. TodoRepositoryImplV3
Основной репозиторий с полной логикой синхронизации:

```kotlin
syncWithRemote(): Result<Unit>
```

#### Алгоритм синхронизации:

1. **Проверка сети** - выходим если нет интернета
2. **Параллельная синхронизация**:
   - Upload: отправка локальных изменений на сервер
   - Download: загрузка изменений с сервера
3. **Разрешение конфликтов** при одновременном изменении
4. **Очистка** удалённых записей

### 2. Статусы синхронизации

```kotlin
enum class TodoSyncStatus {
    LOCAL,     // Только локально, ещё не синхронизировано
    SYNCED,    // Синхронизировано с сервером
    PENDING,   // Ожидает синхронизации
    CONFLICT   // Конфликт версий
}
```

### 3. Стратегии разрешения конфликтов

```kotlin
enum class ConflictResolution {
    KEEP_LOCAL,    // Оставить локальную версию
    KEEP_REMOTE,   // Взять версию с сервера
    KEEP_LATEST,   // Взять более новую по updatedAt (по умолчанию)
    MERGE          // Объединить изменения
}
```

## Сценарии работы

### Создание новой задачи

```
1. User → создаёт Todo
2. Repository → сохраняет в БД со статусом PENDING
3. Repository → если есть сеть, вызывает API.createTodo()
4. API → возвращает remoteId
5. Repository → обновляет remoteId и статус на SYNCED
```

### Обновление существующей задачи

```
1. User → изменяет Todo
2. Repository → обновляет в БД, меняет статус на PENDING
3. Repository → если есть сеть, вызывает API.updateTodo()
4. API → подтверждает обновление
5. Repository → меняет статус на SYNCED
```

### Удаление задачи

```
1. User → удаляет Todo
2. Repository → если есть remoteId:
   - Помечает как __DELETED__ в description
   - Меняет статус на PENDING
3. Repository → если есть сеть, вызывает API.deleteTodo()
4. API → подтверждает удаление
5. Repository → полностью удаляет из БД
```

### Полная синхронизация

```
1. WorkManager/User → запускает syncWithRemote()
2. Repository → параллельно:
   
   UPLOAD:
   - Получает todos со статусом PENDING
   - Группирует по батчам (20 штук)
   - Отправляет API.syncTodos()
   - Обновляет remoteId и статусы
   
   DOWNLOAD:
   - Запрашивает изменения с lastSyncTime
   - Для каждого remote todo:
     - Если новое → создаёт локально
     - Если существует → проверяет конфликт
     - Если конфликт → разрешает по стратегии

3. Repository → разрешает конфликты
4. Repository → очищает удалённые записи
5. Repository → сохраняет время синхронизации
```

## Обработка конфликтов

### Когда возникает конфликт?
- Локальная версия имеет статус PENDING (изменена локально)
- Серверная версия новее чем локальная (изменена на сервере)

### Стратегия KEEP_LATEST (по умолчанию)
```kotlin
if (remoteUpdatedAt > localUpdatedAt) {
    // Применяем версию с сервера
    updateLocal(remoteTodo)
} else {
    // Оставляем локальную версию
    keepLocal()
}
```

### Стратегия MERGE
```kotlin
// Берём title от локальной версии
// Остальные поля от серверной
val merged = remoteTodo.copy(
    title = localTodo.title
)
```

## Автоматические триггеры синхронизации

1. **При старте приложения** (BootReceiver)
2. **При появлении сети** (NetworkReceiver)
3. **Периодически** (WorkManager каждые 15 минут)
4. **После каждого изменения** (если есть сеть)

## Оптимизации

### Батчевая отправка
Вместо отправки каждого todo отдельно, группируем по 20 штук:
```kotlin
pendingTodos.chunked(BATCH_SIZE).forEach { batch ->
    apiService.syncTodos(batch)
}
```

### Параллельная синхронизация
Upload и Download выполняются одновременно:
```kotlin
coroutineScope {
    val uploadJob = async { uploadPendingChanges() }
    val downloadJob = async { downloadRemoteChanges() }
    awaitAll(uploadJob, downloadJob)
}
```

### Инкрементальная синхронизация
Загружаем только изменения с последней синхронизации:
```kotlin
apiService.getUpdatedTodos(lastSyncTimestamp)
```

## Обработка ошибок

- **Нет сети** → откладываем синхронизацию
- **Ошибка API** → повторяем через BackoffPolicy
- **Конфликт версий** → автоматическое разрешение
- **Timeout** → откладываем и повторяем позже

## Тестирование

### Unit тесты
- Моки для API и DAO
- Проверка всех сценариев синхронизации
- Тесты разрешения конфликтов

### Интеграционные тесты
- MockWebServer для эмуляции сервера
- Room in-memory database
- WorkManager test helpers

## Мониторинг

Логирование ключевых метрик:
- Количество успешных/неудачных синхронизаций
- Количество конфликтов и их разрешение
- Время синхронизации
- Размер батчей

## Безопасность

- HTTPS для всех запросов
- Валидация данных с сервера
- Ограничение размера батчей
- Таймауты на сетевые операции